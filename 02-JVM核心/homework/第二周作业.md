**串行GC：**在执行GC时会STW，只有一个线程参与垃圾回收，适用于单核CPU，对于目前多核CPU不适合

**并行GC：**在执行GC时会STW，默认所有内核参与垃圾回收，使用标记整理算法，回收效率高，但是由于其在回收的整个阶段，业务线程都要停止，导致业务线程停顿时间长，因此常作为对吞吐量要求高，对时延不高的场景，例如定时任务调度、异步处理等

**CMS GC：**将垃圾回收拆分为了多个步骤，只有初始标记和最终标记会STW，其余的步骤都是可以和业务线程并发执行，初始标记标记的是GC Root及其引用对象，最终标记之前一般会有并发于清理，因此初始标记和最终标记的时间都比较短，所以CMS GC长用作对时延要求高的场景，例如一般的接口。

**G1 GC：**G1打破了原有物理层面的分代，使用了Region做了逻辑分代，同时使用Remeber Set存储引用记录，同时可以设置预期的GC停顿时间，G1标记Region中垃圾量并排序，在预期的暂停时间内做垃圾回收，通过每次少量回收、多次回收的策略，既保证了GC的预期停顿，又保证了垃圾的清理；因此G1一般用于对延迟有要求的场景。

但是G1自身维护Remeber Set和Collection Set，因此内存占用要比CMS高，因此对于小内存的JVM来说，使用G1反而会增加内存占用，从而增加GC的次数，而对于大内存的JVM，这点内存使用量对于整体来说影响不大，因此大内存JVM一般使用G1，小内存JVM使用CMS，分界线一般在6-8G，在6-8G，CMS和G1差不多，小于6G，直接使用CMS，大于8G，使用G1

ZGC：利用指针染色技术和读屏障实现并发转移对象，降低了GC的停顿时间，缺点是如果对象的分配速率超过了回收速率，就会导致分配停顿

Epsilon：不会做垃圾回收，保留最完整的对象分配，主要用来做内存对象分析，不适用于生产场景

Shenandoah：类似ZGC

